{"id":null,"title":"Ordonnanceur","ccs":"* ----------------------------------\n* Ordonnanceur, ici pour 3 tâches. \n* ----------------------------------\n\n* ------------------\n* 1. Spécification\n* ------------------\n* On voudrait partir d'une tâche seule disant que chaque action \"a_i\" a lieu avant chaque action \"b_i\", correspondant à :\nOrderO = a.b.OrderO ; \n\n* Mais chaque tâche doit être synchronisée avec un processus disant que a1 précède a2 qui précède a3 etc.\n* On munit donc Order0 d'actions sa et ea (start a et end a) pour être commandée par un processus global.\nOrder = sa. a. ea. b. Order ; \n\nCyclic = 'sk. 'ek. 'sl. 'el. 'sm. 'em. Cyclic ;\n* 'sk : start k\n* 'ek : end k\n* 'sl : start l\n* 'el : end l\n* 'sm : start m\n* 'em : end m\n\nOrdonnanceur = (Order[sa1/sa,a1/a,ea1/ea,b1/b] | Order[sa2/sa,a2/a,ea2/ea,b2/b] | Order[sa3/sa,a3/a,ea3/ea,b3/b] |\n                Cyclic[sa1/sk, ea1/ek, sa2/sl, ea2/el, sa3/sm, ea3/em]) \\{sa1,ea1,sa2,ea2,sa3,ea3} ;\n                \n\n* L'ordonnanceur ainsi construit répond aux deux exigences, ce que l'on peut vérifier ainsi.\nSpec1 = Ordonnanceur [tau/a2,tau/b2,tau/a3,tau/b3] ; * On ne garde visibles que a1 et b1.\nSpec2 = Ordonnanceur [tau/b1,tau/b2,tau/b3]; * On ne garde visibles que a1, a2 et a3.\n\n* \nProp1 = a1. b1. Prop1 ;\nProp2 = a1. a2. a3. Prop2 ;\n\n* On doit avoir :\n* Spec1 =  Prop1 \n* Spec2 =  Prop2,  où = est la congruence observationnelle (sous l'outil on utilise l'équivalence observationnelle).\n\n* ------------------------------------\n* 2. Implantation : 3 cellules.\n* ------------------------------------\n\nCell  = 'd. Cell0 ;\n\n* a : a_i\n* b : b_i\n* c : c_i \n* d : c_{i-1}\n\nCell0 = a. (c. b. Cell + b. c. Cell) ;\n* Cell0 = a. b. c. Cell ; \n\n\nRing =  (Cell0[a1/a,c1/c,b1/b,c3/d] | Cell[a2/a, c2/c, b2/b,c1/d] | Cell[a3/a, c3/c, b3/b, c2/d] ) \\ {c1, c2, c3} ;\n\n\n\n                \n                ","properties":[{"className":"Bisimulation","status":0,"options":{"type":"weak","time":null,"firstProcess":"Ring","secondProcess":"Ordonnanceur","comment":""}},{"className":"HML","status":1,"options":{"process":"Ring","definitions":"","topFormula":"<<a1>><<a2>><<b1>>[[b2]]<<a3>><<a1>>[[tau]]<<a2>>[[b2]]ff;"}},{"className":"HML","status":1,"options":{"process":"Ordonnanceur","definitions":"","topFormula":"<<a1>><<a2>><<b1>>[[b2]]<<a3>><<a1>>[[tau]]<<a2>>[[b2]]ff;"}},{"className":"HML","status":0,"options":{"process":"Ordonnanceur","definitions":"X min= <<b1>>tt or ([-]X and <->tt) ;","topFormula":"[[a1]]ff or X ;","comment":"Si on fait a, alors on fera b.\n<a>tt => finally(<b>tt) ;\n = [a]ff or finally(<b>tt) ;\n = [a]ff or (<b>tt  or ([-]finally(<b>tt) and <->tt)) "}},{"className":"Bisimulation","status":0,"options":{"type":"weak","time":null,"firstProcess":"Spec1","secondProcess":"Prop1","comment":""}},{"className":"Bisimulation","status":0,"options":{"type":"weak","time":null,"firstProcess":"Spec2","secondProcess":"Prop2","comment":""}}],"inputMode":"CCS"}